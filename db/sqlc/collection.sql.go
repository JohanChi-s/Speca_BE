// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: collection.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCollection = `-- name: CreateCollection :one
INSERT INTO "Collection" (
  "name",
  "description",
  "icon",
  "isSaving",
  "canShare",
  "childCollectionIds",
  "downloadPermission",
  "createdAt",
  "updatedAt",
  "workspaceId",
  "parentCollectionId",
  "ownerUserId"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, name, description, icon, "isSaving", "canShare", "childCollectionIds", "downloadPermission", "createdAt", "updatedAt", "workspaceId", "parentCollectionId", "ownerUserId"
`

type CreateCollectionParams struct {
	Name               pgtype.Text      `json:"name"`
	Description        pgtype.Text      `json:"description"`
	Icon               pgtype.Text      `json:"icon"`
	IsSaving           pgtype.Bool      `json:"isSaving"`
	CanShare           pgtype.Bool      `json:"canShare"`
	ChildCollectionIds pgtype.Text      `json:"childCollectionIds"`
	DownloadPermission []byte           `json:"downloadPermission"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	WorkspaceId        pgtype.UUID      `json:"workspaceId"`
	ParentCollectionId pgtype.UUID      `json:"parentCollectionId"`
	OwnerUserId        pgtype.UUID      `json:"ownerUserId"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.IsSaving,
		arg.CanShare,
		arg.ChildCollectionIds,
		arg.DownloadPermission,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.WorkspaceId,
		arg.ParentCollectionId,
		arg.OwnerUserId,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.IsSaving,
		&i.CanShare,
		&i.ChildCollectionIds,
		&i.DownloadPermission,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceId,
		&i.ParentCollectionId,
		&i.OwnerUserId,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM "Collection"
WHERE "id" = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCollection, id)
	return err
}

const getCollectionByID = `-- name: GetCollectionByID :one
SELECT id, name, description, icon, "isSaving", "canShare", "childCollectionIds", "downloadPermission", "createdAt", "updatedAt", "workspaceId", "parentCollectionId", "ownerUserId" FROM "Collection"
WHERE "id" = $1 LIMIT 1
`

func (q *Queries) GetCollectionByID(ctx context.Context, id uuid.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByID, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.IsSaving,
		&i.CanShare,
		&i.ChildCollectionIds,
		&i.DownloadPermission,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceId,
		&i.ParentCollectionId,
		&i.OwnerUserId,
	)
	return i, err
}

const listCollections = `-- name: ListCollections :many
SELECT id, name, description, icon, "isSaving", "canShare", "childCollectionIds", "downloadPermission", "createdAt", "updatedAt", "workspaceId", "parentCollectionId", "ownerUserId" FROM "Collection"
ORDER BY "createdAt"
LIMIT $1
OFFSET $2
`

type ListCollectionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCollections(ctx context.Context, arg ListCollectionsParams) ([]Collection, error) {
	rows, err := q.db.Query(ctx, listCollections, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.IsSaving,
			&i.CanShare,
			&i.ChildCollectionIds,
			&i.DownloadPermission,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceId,
			&i.ParentCollectionId,
			&i.OwnerUserId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollection = `-- name: UpdateCollection :exec
UPDATE "Collection"
SET
  "name" = $2,
  "description" = $3,
  "icon" = $4,
  "isSaving" = $5,
  "canShare" = $6,
  "childCollectionIds" = $7,
  "downloadPermission" = $8,
  "updatedAt" = $9,
  "workspaceId" = $10,
  "parentCollectionId" = $11,
  "ownerUserId" = $12
WHERE "id" = $1
`

type UpdateCollectionParams struct {
	ID                 uuid.UUID        `json:"id"`
	Name               pgtype.Text      `json:"name"`
	Description        pgtype.Text      `json:"description"`
	Icon               pgtype.Text      `json:"icon"`
	IsSaving           pgtype.Bool      `json:"isSaving"`
	CanShare           pgtype.Bool      `json:"canShare"`
	ChildCollectionIds pgtype.Text      `json:"childCollectionIds"`
	DownloadPermission []byte           `json:"downloadPermission"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	WorkspaceId        pgtype.UUID      `json:"workspaceId"`
	ParentCollectionId pgtype.UUID      `json:"parentCollectionId"`
	OwnerUserId        pgtype.UUID      `json:"ownerUserId"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) error {
	_, err := q.db.Exec(ctx, updateCollection,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.IsSaving,
		arg.CanShare,
		arg.ChildCollectionIds,
		arg.DownloadPermission,
		arg.UpdatedAt,
		arg.WorkspaceId,
		arg.ParentCollectionId,
		arg.OwnerUserId,
	)
	return err
}
