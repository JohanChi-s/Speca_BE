// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type EnumActionEventAction string

const (
	EnumActionEventActionDownload   EnumActionEventAction = "Download"
	EnumActionEventActionUpload     EnumActionEventAction = "Upload"
	EnumActionEventActionEdit       EnumActionEventAction = "Edit"
	EnumActionEventActionDelete     EnumActionEventAction = "Delete"
	EnumActionEventActionAddRole    EnumActionEventAction = "AddRole"
	EnumActionEventActionRemoveRole EnumActionEventAction = "RemoveRole"
	EnumActionEventActionDuplicate  EnumActionEventAction = "Duplicate"
	EnumActionEventActionComment    EnumActionEventAction = "Comment"
	EnumActionEventActionShare      EnumActionEventAction = "Share"
	EnumActionEventActionAssign     EnumActionEventAction = "Assign"
	EnumActionEventActionStar       EnumActionEventAction = "Star"
	EnumActionEventActionPublic     EnumActionEventAction = "Public"
	EnumActionEventActionPrivate    EnumActionEventAction = "Private"
)

func (e *EnumActionEventAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EnumActionEventAction(s)
	case string:
		*e = EnumActionEventAction(s)
	default:
		return fmt.Errorf("unsupported scan type for EnumActionEventAction: %T", src)
	}
	return nil
}

type NullEnumActionEventAction struct {
	EnumActionEventAction EnumActionEventAction `json:"EnumActionEventAction"`
	Valid                 bool                  `json:"valid"` // Valid is true if EnumActionEventAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEnumActionEventAction) Scan(value interface{}) error {
	if value == nil {
		ns.EnumActionEventAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EnumActionEventAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEnumActionEventAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EnumActionEventAction), nil
}

type EnumCommentStatus string

const (
	EnumCommentStatusDone  EnumCommentStatus = "Done"
	EnumCommentStatusTodo  EnumCommentStatus = "Todo"
	EnumCommentStatusDoing EnumCommentStatus = "Doing"
)

func (e *EnumCommentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EnumCommentStatus(s)
	case string:
		*e = EnumCommentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EnumCommentStatus: %T", src)
	}
	return nil
}

type NullEnumCommentStatus struct {
	EnumCommentStatus EnumCommentStatus `json:"EnumCommentStatus"`
	Valid             bool              `json:"valid"` // Valid is true if EnumCommentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEnumCommentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EnumCommentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EnumCommentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEnumCommentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EnumCommentStatus), nil
}

type ActionEvent struct {
	ID           uuid.UUID        `json:"id"`
	Action       interface{}      `json:"action"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	Actor        pgtype.UUID      `json:"actor"`
	Assignee     pgtype.UUID      `json:"assignee"`
	Assigner     pgtype.UUID      `json:"assigner"`
	DocumentId   pgtype.UUID      `json:"documentId"`
	CollectionId pgtype.UUID      `json:"collectionId"`
}

type Collection struct {
	ID                 uuid.UUID        `json:"id"`
	Name               pgtype.Text      `json:"name"`
	Description        pgtype.Text      `json:"description"`
	Icon               pgtype.Text      `json:"icon"`
	IsSaving           pgtype.Bool      `json:"isSaving"`
	CanShare           pgtype.Bool      `json:"canShare"`
	ChildCollectionIds pgtype.Text      `json:"childCollectionIds"`
	DownloadPermission []byte           `json:"downloadPermission"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	WorkspaceId        pgtype.UUID      `json:"workspaceId"`
	ParentCollectionId pgtype.UUID      `json:"parentCollectionId"`
	OwnerUserId        pgtype.UUID      `json:"ownerUserId"`
}

type CollectionMember struct {
	CollectionID pgtype.UUID `json:"collection_id"`
	MemberID     pgtype.UUID `json:"member_id"`
}

type CollectionTag struct {
	FolderID pgtype.UUID `json:"folder_id"`
	TagID    pgtype.UUID `json:"tag_id"`
}

type Comment struct {
	ID        uuid.UUID        `json:"id"`
	Content   pgtype.Text      `json:"content"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	UserId          pgtype.UUID      `json:"userId"`
	DocumentId      pgtype.UUID      `json:"documentId"`
	ParentCommentId pgtype.UUID      `json:"parentCommentId"`
}

type Document struct {
	ID          uuid.UUID        `json:"id"`
	Title       pgtype.Text      `json:"title"`
	Text        pgtype.Text      `json:"text"`
	Emoji       pgtype.Text      `json:"emoji"`
	IsPublic    pgtype.Bool      `json:"isPublic"`
	IsFullWidth pgtype.Bool      `json:"isFullWidth"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	AuthorId     pgtype.UUID      `json:"authorId"`
	TeamId       pgtype.UUID      `json:"teamId"`
	WorkspaceId  pgtype.UUID      `json:"workspaceId"`
	CollectionId pgtype.UUID      `json:"collectionId"`
}

type DocumentCollection struct {
	DocumentID   pgtype.UUID `json:"document_id"`
	CollectionID pgtype.UUID `json:"collection_id"`
}

type DocumentTag struct {
	DocumentID pgtype.UUID `json:"document_id"`
	TagID      pgtype.UUID `json:"tag_id"`
}

type Member struct {
	ID           uuid.UUID        `json:"id"`
	UserId       pgtype.UUID      `json:"userId"`
	CollectionId pgtype.UUID      `json:"collectionId"`
	Role         []byte           `json:"role"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
}

type Position struct {
	ID        uuid.UUID        `json:"id"`
	Line      pgtype.Int4      `json:"line"`
	Col       pgtype.Int4      `json:"col"`
	ToLine    pgtype.Text      `json:"toLine"`
	ToCol     pgtype.Text      `json:"toCol"`
	Content   pgtype.Text      `json:"content"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt  pgtype.Timestamp `json:"updatedAt"`
	CommentsId pgtype.UUID      `json:"commentsId"`
}

type Profile struct {
	ID        uuid.UUID        `json:"id"`
	UserId    pgtype.UUID      `json:"userId"`
	FullName  pgtype.Text      `json:"fullName"`
	Age       pgtype.Int4      `json:"age"`
	Address   pgtype.Text      `json:"address"`
	AvatarUrl pgtype.Text      `json:"avatarUrl"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
}

type Tag struct {
	ID          uuid.UUID   `json:"id"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

type Team struct {
	ID              uuid.UUID        `json:"id"`
	Name            pgtype.Text      `json:"name"`
	AvatarUrl       pgtype.Text      `json:"avatarUrl"`
	SubDomain       pgtype.Text      `json:"subDomain"`
	Theme           pgtype.Text      `json:"theme"`
	CanComment      pgtype.Bool      `json:"canComment"`
	CanShare        pgtype.Bool      `json:"canShare"`
	InviteRequired  pgtype.Bool      `json:"inviteRequired"`
	DefaultUserRole pgtype.Text      `json:"defaultUserRole"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	Url       pgtype.Text      `json:"url"`
}

type TeamDocument struct {
	TeamID     pgtype.UUID `json:"team_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

type TeamWorkspace struct {
	TeamID      pgtype.UUID `json:"team_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

type User struct {
	ID        uuid.UUID   `json:"id"`
	Email     pgtype.Text `json:"email"`
	Username  pgtype.Text `json:"username"`
	Password  pgtype.Text `json:"password"`
	FirstName pgtype.Text `json:"firstName"`
	LastName  pgtype.Text `json:"lastName"`
	IsAdmin   pgtype.Bool `json:"isAdmin"`
	IsActive  pgtype.Bool `json:"isActive"`
	IsViewer  pgtype.Bool `json:"isViewer"`
	Language  pgtype.Text `json:"language"`
	// Automatically updated by the database
	LastActiveAt pgtype.Timestamp `json:"lastActiveAt"`
	Roles        []byte           `json:"roles"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
}

type UserDocument struct {
	UserID     pgtype.UUID `json:"user_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

type UserTeam struct {
	UserID pgtype.UUID `json:"user_id"`
	TeamID pgtype.UUID `json:"team_id"`
}

type UserWorkspace struct {
	UserID      pgtype.UUID `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

type Workspace struct {
	ID        uuid.UUID        `json:"id"`
	Name      pgtype.Text      `json:"name"`
	Domain    pgtype.Text      `json:"domain"`
	IsPublic  pgtype.Bool      `json:"isPublic"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	// Automatically updated by the database
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	Url       pgtype.Text      `json:"url"`
}

type WorkspaceDocument struct {
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	DocumentID  pgtype.UUID `json:"document_id"`
}
